---
title: "Binary Timer Appendix"
subtitle: "Unit 4 Optional Project"
pagetitle: "{{< meta title >}} | {{< var title-fix >}}"
order: 10
---

<h3>Base Conversion with Method 1 (<em>Short Division by Two with
Remainder</em>)</h3>

First a reminder how to extract each digit in base 10 system.



**Example:** If you were trying to extract the digits of a
number, say, 527 in base 10, you would take the following steps.<br />
<img src="/img/6-computers/BinaryClock_img/527.png" title="Decimal Digit Extraction" alt="Decimal Digit Extraction" class="ms-4" width="459"/><br />
(Recall that the floor() function rounds a number down to the closest
integer.)<br />

<ol>

<li>Find the "ones" digit, via remainder in 527 divided by 10: <br />
527 mod 10 = **7**<br /> Get quotient:<br /> floor(527/10)=
52</li>

<li>Repeat, find the "tens" digit, via remainder in 52 divided by 10:
<br /> 52 mod 10 = **2**<br /> Get quotient:<br />
floor(52/10) = 5</li>

<li>Repeat, find the "hundreds" digit, via remainder in 5 divided by 10:
<br /> 5 mod 10 = **5**<br /> Get quotient:<br />
floor(5/10) = 0</li>

</ol>



This is where we stop. So 527= **5**(100) +
**2**(10) + **7**(1)

Note with the algorithm we extracted the digits right to left. (7
first, 2 next, 5 last)



**Example:** If you apply a similar procedure to get the
binary representation of a number, say, 25, you would take the following
steps.<br />
<img src="/img/6-computers/BinaryClock_img/25.png" title="Binary Digit Extraction" alt="Binary Digit Extraction" class="ms-4" width="747"/><br />

<ol>

<li>Find the "ones" digit, via remainder in 25 divided by 2: <br /> 25
mod 2 = **1**<br /> Get quotient:<br /> floor(25/2)=
12</li>

<li>Repeat, find the "twos" digit, via remainder in 12 divided by 2:
<br /> 12 mod 2= **0**<br /> Get quotient:<br />
floor(12/2)= 6</li>

<li>Repeat, find the "fours" digit, via remainder in 6 divided by 2:
<br /> 6 mod 2= **0**<br /> Get quotient:<br /> floor(6/2)=
3</li>

<li>Repeat, find the "eights" digit, via remainder in 3 divided by 2:
<br /> 3 mod 2= **1**<br /> Get quotient:<br /> floor(3/2)=
1</li>

<li>Repeat, find the "sixteens" digit, via remainder in 1 divided by 2:
<br /> 1 mod 2= **1**<br /> Get quotient:<br /> floor(1/2)=
0</li>

</ol>



This is where we stop. Note with the algorithm again we extracted the
digits right to left.

So 25= **1**(16) + **1**(8)+
**0**(4) + **0**(2) + **1**(1) =
(**11001**)<sub>2</sub>

Using these examples come up with an algorithm to represent any base
10 number in base 2.

<h3>Base conversion with Method 2: (<em>Descending Powers of Two and
Subtraction</em>)</h3>

<b>Example:</b> If you are trying to get the binary representation of a
number, say, 25, you would take the following steps.<br>
<img src="/img/6-computers/BinaryClock_img/powersOfTwo.png" title="powers of 2" alt="powers of 2" class="ms-4" width="192"/><br>

```{=html}
<pre  style="width:400px">
Is 2<sup>4</sup> =16 contained in 25? Yes, write <b>1</b>.
25-16=9
Is 2<sup>3</sup> = 8 contained in  9? Yes, write <b>1</b>.
9-8=1
Is 2<sup>2</sup> = 4 contained in  1? No,  write <b>0</b>.
Is 2<sup>1</sup> = 2 contained in  1? No,  write <b>0</b>.
Is 2<sup>0</sup> = 1 contained in  1? Yes, write <b>1</b>.
1-1=0  Done.
</pre>
```
<img src="/img/6-computers/BinaryClock_img/BinaryConversion.png" title="Binary conversion" alt="Binary conversion" class="ms-4" width="195"/>
